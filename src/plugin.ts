/**
 * Bun Plugin for loading .java files directly
 * Enables: import { MyClass } from "./MyClass.java"
 */

import type { BunPlugin } from "bun";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { join, dirname, basename } from "path";
import { JavaBuilder } from "./java/builder";
import { WasmBridge } from "./wasm/bridge";
import { ClassFileParser } from "./java/classfile";
import { javaTypeToTs } from "./wasm/types";

/**
 * Cache for loaded WASM instances
 */
const wasmInstanceCache = new Map<string, any>();

/**
 * Plugin configuration
 */
export interface JavaPluginConfig {
  cacheDir?: string;
  wasmOutDir?: string;
  classOutDir?: string;
  debug?: boolean;
}

/**
 * Create the Bun plugin for .java file loading
 */
export function javaPlugin(config: JavaPluginConfig = {}): BunPlugin {
  const cacheDir = config.cacheDir ?? ".qin/cache";
  const wasmOutDir = config.wasmOutDir ?? ".qin/wasm";
  const classOutDir = config.classOutDir ?? ".qin/classes";
  const debug = config.debug ?? false;

  return {
    name: "qin-java-loader",
    
    setup(build) {
      // Handle .java file imports
      build.onLoad({ filter: /\.java$/ }, async (args) => {
        const javaPath = args.path;
        const className = basename(javaPath, ".java");
        
        if (debug) {
          console.log(`[qin] Loading ${className} from ${javaPath}`);
        }

        try {
          // Step 1: Compile Java to .class
          const builder = new JavaBuilder({
            srcDir: dirname(javaPath),
            outDir: classOutDir,
          });

          const compileSuccess = await builder.compile([javaPath]);
          if (!compileSuccess) {
            return {
              contents: `throw new Error("Failed to compile ${className}.java");`,
              loader: "js",
            };
          }

          // Step 2: Compile .class to WASM
          const bridge = new WasmBridge({
            cacheDir,
            wasmOutDir,
            classOutDir,
            debug,
          });

          const wasmResult = await bridge.compileClass(javaPath);
          if (!wasmResult.success) {
            return {
              contents: `throw new Error("Failed to compile ${className} to WASM: ${wasmResult.error}");`,
              loader: "js",
            };
          }

          // Step 3: Parse class file to get exports
          const classFilePath = join(classOutDir, `${className}.class`);
          let exports: { methods: string[]; fields: string[] } = { methods: [], fields: [] };
          
          if (existsSync(classFilePath)) {
            try {
              const parser = new ClassFileParser(classFilePath);
              const classInfo = parser.parse();
              exports.methods = classInfo.methods
                .filter(m => m.isPublic && m.name !== "<init>" && m.name !== "<clinit>")
                .map(m => m.name);
              exports.fields = classInfo.fields
                .filter(f => f.isPublic)
                .map(f => f.name);
            } catch (e) {
              if (debug) {
                console.warn(`[qin] Could not parse class file: ${e}`);
              }
            }
          }

          // Step 4: Generate loader code
          const loaderCode = generateLoaderCode(className, wasmResult.jsGluePath!, exports);

          return {
            contents: loaderCode,
            loader: "js",
          };
        } catch (e: any) {
          return {
            contents: `throw new Error("Error loading ${className}.java: ${e.message}");`,
            loader: "js",
          };
        }
      });
    },
  };
}

/**
 * Generate JavaScript code that loads the WASM module
 */
function generateLoaderCode(
  className: string,
  jsGluePath: string,
  exports: { methods: string[]; fields: string[] }
): string {
  const methodExports = exports.methods.map(m => `  ${m}: (...args) => wasmExports.${m}?.(...args)`).join(",\n");
  const fieldExports = exports.fields.map(f => `  get ${f}() { return wasmExports.${f}; }`).join(",\n");

  return `
// Auto-generated by Qin Java Plugin
// Class: ${className}

let wasmInstance = null;
let wasmExports = null;

async function ensureLoaded() {
  if (wasmInstance) return;
  
  const glue = await import("${jsGluePath}");
  wasmInstance = await glue.load();
  wasmExports = glue.getExports();
}

// Lazy-loading proxy
const ${className} = new Proxy({}, {
  get(target, prop) {
    if (prop === 'then') return undefined; // Not a Promise
    
    return async (...args) => {
      await ensureLoaded();
      if (typeof wasmExports[prop] === 'function') {
        return wasmExports[prop](...args);
      }
      return wasmExports[prop];
    };
  }
});

export { ${className} };
export default ${className};
`;
}

/**
 * Generate TypeScript declaration file for a Java class
 */
export function generateDtsFile(
  className: string,
  classFilePath: string,
  outputPath: string
): void {
  const parser = new ClassFileParser(classFilePath);
  const classInfo = parser.parse();

  const methods = classInfo.methods
    .filter(m => m.isPublic && m.name !== "<init>" && m.name !== "<clinit>")
    .map(m => {
      const params = m.params.map((p, i) => `arg${i}: ${javaTypeToTs(p)}`).join(", ");
      const returnType = javaTypeToTs(m.returnType);
      const asyncReturn = returnType === "void" ? "Promise<void>" : `Promise<${returnType}>`;
      return `  ${m.name}(${params}): ${asyncReturn};`;
    })
    .join("\n");

  const fields = classInfo.fields
    .filter(f => f.isPublic)
    .map(f => `  readonly ${f.name}: ${javaTypeToTs(f.type)};`)
    .join("\n");

  const dts = `// Auto-generated by Qin
// TypeScript declarations for ${className}

export interface ${className}Type {
${methods}
${fields}
}

export declare const ${className}: ${className}Type;
export default ${className};
`;

  const dir = dirname(outputPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
  writeFileSync(outputPath, dts);
}

// Default export
export default javaPlugin;
